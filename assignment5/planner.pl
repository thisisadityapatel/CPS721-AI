%%%%% This file contains the generic planner used to solve the two problems
%%%%% DO NOT EDIT THIS FILE
%%%%% DO NOT SUBMIT THIS FILE

% The following is the max_length helper predicate
max_length([], N) :- N >= 0.
max_length([First | L], N1) :- N1 > 0, N is N1 - 1, max_length(L, N).


% Defines legal_move and the initial situation
legal_move([A | S], A, S) :- poss(A, S).  % Defines a move as legal if there is a precondition axiom that allows for it
initial_state([]). % Defines the initial situation


% The following is the reachable helper predicate
% Notice it takes in a Mode argument, which may take the value of "regular" or "heuristic"
% When "heuristic" is used, the reachable predicate will use defined declarative heuristics for pruning. 
% If regular is used, then no pruning is done
reachable(Mode, S, []) :- initial_state(S).
reachable(regular, S2, [M | RestActions]) :- reachable(regular, S1, RestActions), legal_move(S2, M, S1).
reachable(heuristic, S2, [M | RestActions]) :- reachable(heuristic, S1, RestActions),
                    legal_move(S2, M, S1),
                    not useless(M, RestActions).


% This is the main predicate for solving a problem. It has the signature solve_problem(Mode, GoalID, Bound, Plan)
% where these arguments are defined as follows:
%   Mode - an input argument that defines whether to use declarative heuristics for pruning or not.
%          Set Mode to heuristic (for pruning) and regular (for no pruning). 
%   GoalID - an input argument that sets which goal state the plan should achieve. 
%   Bound - an input argument which sets the maximum of the number of actions in the plan.
%   Plan - an output argument which will be set to the sequence of actions in the final plan
% Note that this predicate also prints out runtime information
solve_problem(Mode, GoalID, Bound, Plan)  :-  C0 is cputime,     % C0 is time when program starts %
          max_length(Plan, Bound),          % Bound is the maximal length of Plan   %
          reachable(Mode, S, Plan),
          goal_state(GoalID, S),           % A situation S must be a solution of the problem %
          Cf is cputime, Diff is Cf - C0, nl,     % Cf is time when program finishes  %
          write('Elapsed time (sec): '), write(Diff), nl.

